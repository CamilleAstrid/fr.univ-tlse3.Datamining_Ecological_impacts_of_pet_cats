---
title: "DataAnalysisCats"
author: "AMOUROUX Jan RODRIGES Camille-Astrid"
date: "`r Sys.Date()`"
output: 
  html_document: 
    fig_width: 8
    fig_height: 6
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align="center", fig.width=6, fig.height=6, fig.path="Figs/", echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE)
```

```{r, include=FALSE}
library(ade4);  library(tidyverse);  library(GGally)
```

Variaable que nous voulons prédire : study.name (leur lieu de résidence)

## Overture des 4 csv : 

```{r}
CatAus = read.csv("../data/Pet Cats Australia.csv"
                  , stringsAsFactors = T)
CatUS = read.csv("../data/Pet Cats United States.csv"
                 , stringsAsFactors = T)
CatUK = read.csv("../data/Pet Cats United Kingdom.csv"
                 , stringsAsFactors = T)
CatNZ = read.csv("../data/Pet Cats New Zealand.csv"
                 , stringsAsFactors = T)
```

1er problème : tous les tableaux n'ont pas le même nombre de Variables

```{r}
summary(CatAus)

summary(CatUS)

summary(CatUK)

summary(CatNZ)
```

Les seules variables communes a tous les tableaux : 

event.id    visible   timestamp   sensor.type   location.long   location.lat    algorithm.marked.outlier    manually.marked.outlier    individual.taxon.canonical.name   tag.local.identifier    individual.local.identifier   study.name 


Pour éviter de biaisé, nous allon sretirer les outliers (obtenu par les .marked.outliers)

## rm des variables spécifique de chaque talbleau

```{r}
CatAus = subset.data.frame(CatAus,
                           select = c("event.id","visible","timestamp","sensor.type","location.long","location.lat",
                                    "algorithm.marked.outlier","manually.marked.outlier","individual.taxon.canonical.name",
                                    "tag.local.identifier","individual.local.identifier","study.name"))
CatUS = subset.data.frame(CatUS, 
                           select = c("event.id","visible","timestamp","sensor.type","location.long","location.lat",
                                    "algorithm.marked.outlier","manually.marked.outlier","individual.taxon.canonical.name",
                                    "tag.local.identifier","individual.local.identifier","study.name"))
CatUK = subset.data.frame(CatUK, 
                           select = c("event.id","visible","timestamp","sensor.type","location.long","location.lat",
                                    "algorithm.marked.outlier","manually.marked.outlier","individual.taxon.canonical.name",
                                    "tag.local.identifier","individual.local.identifier","study.name"))
CatNZ = subset.data.frame(CatNZ, 
                           select = c("event.id","visible","timestamp","sensor.type","location.long","location.lat",
                                    "algorithm.marked.outlier","manually.marked.outlier","individual.taxon.canonical.name",
                                    "tag.local.identifier","individual.local.identifier","study.name"))
```

## concaténer les tables en super-tables

```{r}
CatComplet = merge.data.frame(CatAus, CatUS,
                              all.x = T, all.y= T)
CatComplet = merge.data.frame(CatComplet, CatUK,
                              all.x = T, all.y= T)
CatComplet = merge.data.frame(CatComplet, CatNZ,
                              all.x = T, all.y= T)
head(which(CatComplet$algorithm.marked.outlier != ""))

CatCompletwoOutliers = subset.data.frame(CatComplet, CatComplet$manually.marked.outlier != "true")
# si on fait confiance a leur algo ajouter : & CatComplet$algorithm.marked.outlier != "true" 
```

/!\\ id est spécifique a chaque chat donc doit être rm. (dans le chunk ou nous supprimons les colonnes), 

Pour les variables non significative : 


* tag.local.identifier == individual.local.identifier

* individual.taxon.canonical.name => sépare rien

* sensor.type => sépare rien

* visible => sépare rien

```{r}
unique(CatCompletwoOutliers$algorithm.marked.outlier);  unique(CatCompletwoOutliers$manually.marked.outlier)
```

Il ne reste que ceux marqué en false ou rien pour les outliers. Nous allons supprimer cette colone car n'informe pas sur les chats

```{r}
CatCompletwoOutliers = subset.data.frame(CatCompletwoOutliers,
                                        select = c("location.long","location.lat","timestamp",
                                    "tag.local.identifier","study.name"))
```

```{r}
summary(CatCompletwoOutliers)
unique(CatCompletwoOutliers$study.name)
```


```{r}
par(mfrow = c(1,2))
plot(study.name~location.long+location.lat
     , data = CatCompletwoOutliers,
     col = c("red3","salmon2","blue4","coral4"))
```
NZ = red,   UK = salmon,   US = blue,    Aus = coral

